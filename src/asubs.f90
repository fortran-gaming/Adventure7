LOGICAL FUNCTION AJAR(OBJECT)
  USE ALLCOM
  implicit none
  INTEGER(4), intent(in) :: OBJECT
  LOGICAL HINGED,VESSEL
  AJAR=BTEST(OBJCON(OBJECT),OPENBT).OR.(VESSEL(OBJECT).AND..NOT.HINGED(OBJECT))
END FUNCTION AJAR

LOGICAL FUNCTION AT(OBJECT)
  USE ALLCOM
  implicit none
!     TRUE IF ON EITHER SIDE OF TWO-PLACED OBJECT

  INTEGER, intent(in) :: OBJECT

  AT = .FALSE.
  IF (OBJECT>=1.AND.OBJECT.LE.MAXOBJ) AT=PLACE(OBJECT)==LOC.OR.FIXED(OBJECT)==LOC
 END FUNCTION AT

   LOGICAL FUNCTION BLIND()
      USE ALLCOM
  implicit none
!     TRUE IF DARKNESS OR GLARE

      LOGICAL, external :: DARK,ATHAND

      BLIND=DARK().OR.(LOC.EQ.200.AND.ATHAND(LAMP).AND.PROP(LAMP).EQ.1)
      END

INTEGER FUNCTION CONFUZ()
  implicit none
!     GENERATES VARIANT OF "DON'T UNDERSTAND THAT" MESSAGE.

  LOGICAL,external :: PCT

  CONFUZ=60
  IF (PCT(50)) CONFUZ=61
  IF (PCT(33)) CONFUZ=13
  IF (PCT(25)) CONFUZ=347
  IF (PCT(20)) CONFUZ=195
END function confuz

LOGICAL FUNCTION DARK()
  USE ALLCOM
  implicit none

  LOGICAL, external :: ATHAND

  DARK=.FALSE.
  IF (LOC>0) DARK=MOD(LOCCON(LOC),2)==0.AND.(PROP(LAMP)==0.OR..NOT.ATHAND(LAMP))
END function dark

LOGICAL FUNCTION DEAD(OBJECT)
  USE ALLCOM,only: objcon,deadbt
    implicit none
  INTEGER OBJECT
  DEAD=BTEST(OBJCON(OBJECT),DEADBT)
END function dead

SUBROUTINE DESTROY(OBJECT)
  implicit none
  INTEGER, intent(in) :: OBJECT
  CALL MOVE(OBJECT,0)
END subroutine destroy

LOGICAL FUNCTION EDIBLE(OBJECT)
  USE ALLCOM, only: objcon
  implicit none

  INTEGER, intent(in) :: OBJECT

  EDIBLE=BTEST(OBJCON(OBJECT),7)
END function edible

LOGICAL FUNCTION ENCLSD(OBJECT)
  USE ALLCOM,only: maxobj, place
  implicit none

  INTEGER, intent(in) :: OBJECT
  ENCLSD=.FALSE.
  IF (OBJECT >= 1 .AND. OBJECT <= MAXOBJ) ENCLSD=PLACE(OBJECT) < -1
END FUNCTION ENCLSD

LOGICAL FUNCTION FORCED(L)
  USE ALLCOM, only: loccon
  implicit none
!     A FORCED LOCATION IS ONE FROM WHICH ADVENTURER IS IMMEDIATELY BOUNCED TO ANOTHER.
!     NORMAL USE IS FOR DEATH (FORCE TO LOC ZERO) AND FOR DESCRIPTIONS OF JOURNEY FROM ONE PLACE TO ANOTHER.
  INTEGER, intent(in) :: L

  FORCED=.FALSE.

  IF (L > 0) FORCED=LOCCON(L) == 2
END function forced

LOGICAL FUNCTION HERE(OBJECT)
  USE ALLCOM
  implicit none
!     TRUE IF THE OBJECT IS AT "LOC" OR IS BEING CARRIED
  INTEGER, intent(in) :: OBJECT
  LOGICAL,external :: TOTING

  HERE = .FALSE.
  IF (OBJECT > 1 .AND. OBJECT <= MAXOBJ) HERE=PLACE(OBJECT) == LOC .OR. TOTING(OBJECT)
END function here

LOGICAL FUNCTION HINGED(OBJECT)
  USE ALLCOM,only: objcon
  implicit none
  INTEGER,intent(in) :: OBJECT
  HINGED=BTEST(OBJCON(OBJECT),1)
END function hinged

LOGICAL FUNCTION HOLDNG(OBJECT)
  USE ALLCOM
  implicit none
  INTEGER,intent(in) :: OBJECT

  HOLDNG = .FALSE.
  IF (OBJECT >= 1 .OR. OBJECT <= MAXOBJ) HOLDNG=PLACE(OBJECT) == -1
END function holdng

LOGICAL FUNCTION INSIDE(L)
      USE ALLCOM
  implicit none
!     TRUE IF LOCATION IS WELL WITHIN THE CAVE

      INTEGER L
      LOGICAL OUTSID
      INSIDE=.NOT.OUTSID(L).AND..NOT.BTEST(LOCCON(L),5)
END function inside

SUBROUTINE JUGGLE(OBJECT)
      USE ALLCOM
    implicit none
!     JUGGLE AN OBJECT BY PICKING IT UP AND PUTTING IT DOWN AGAIN TO GET THE OBJECT TO THE FRONT OF THE CHAIN OF THINGS AT ITS LOC.

      INTEGER OBJECT,I,J

      I=PLACE(OBJECT)
      J=FIXED(OBJECT)
      CALL MOVE(OBJECT,I)
      CALL MOVE(OBJECT+MAXOBJ,J)
END subroutine juggle

INTEGER FUNCTION LIQ(OBJECT)
      USE ALLCOM
implicit none
      INTEGER OBJECT,IQ

      LIQ = 0
      IF (OBJECT.EQ.BOTTLE.OR.OBJECT.EQ.CASK) THEN
         IQ = MAX(PROP(OBJECT)+1,-1-(PROP(OBJECT)+1))
         IF (IQ.GT.0) LIQ=LIQTYP(IQ)
      ENDIF
END function liq

INTEGER FUNCTION LIQ2(PBOTL)
      USE ALLCOM
implicit none
      INTEGER, intent(in) :: PBOTL

      LIQ2=(1-PBOTL)*WATER+(PBOTL/2)*(WATER+OIL)+(PBOTL/4)*(WATER+WINE-2*OIL)
END function liq2

INTEGER FUNCTION LIQLOC()
      USE ALLCOM
implicit none
      INTEGER LIQ2
      LIQLOC=LIQ2((MOD(LOCCON(LOC)/8,2)*(MOD(LOCCON(LOC)/2*2,16)-9)+1))
END function liqloc

LOGICAL FUNCTION LIVING(OBJECT)
      USE ALLCOM
implicit none
      INTEGER, intent(in) :: OBJECT
      LIVING=BTEST(OBJCON(OBJECT),9)
END function living

LOGICAL FUNCTION LOCKED(OBJECT)
      USE ALLCOM
implicit none
      INTEGER OBJECT
      LOCKED=BTEST(OBJCON(OBJECT),4)
END function locked

LOGICAL FUNCTION LOCKS(OBJECT)
      USE ALLCOM
implicit none
      INTEGER,intent(in) :: OBJECT
      LOCKS=BTEST(OBJCON(OBJECT),3)
END function locks

INTEGER FUNCTION NOWAY()
implicit none
!     GENERATE'S SOME VARIANT OF "CAN'T DO THAT" MESSAGE.

      LOGICAL,external :: PCT

      NOWAY=14
      IF (PCT(50)) NOWAY=110
      IF (PCT(33)) NOWAY=147
      IF (PCT(25)) NOWAY=250
      IF (PCT(20)) NOWAY=262
      IF (PCT(17)) NOWAY=25
      IF (PCT(14)) NOWAY=345
      IF (PCT(12)) NOWAY=346
END function noway

LOGICAL FUNCTION OPAQUE(OBJECT)
      USE ALLCOM
implicit none

      INTEGER,intent(in) :: OBJECT
      OPAQUE=BTEST(OBJCON(OBJECT),6)
END function opaque

LOGICAL FUNCTION OUTSID(L)
      USE ALLCOM, only: loccon
implicit none
      INTEGER,intent(in) :: L
      OUTSID=BTEST(LOCCON(L),6)
END function outsid

LOGICAL FUNCTION PCT(N)
implicit none
INTEGER,external :: RANZ
integer, intent(in) :: N

!     TRUE N% OF THE TIME (N INTEGER FROM 0 TO 100)

PCT=RANZ(100)<N
END function pct

LOGICAL FUNCTION PLURAL(OBJECT)
  USE ALLCOM
implicit none
!     TRUE IF OBJECT IS A "BUNCH" OF THINGS (COINS, SHOES).

  INTEGER,intent(in) :: OBJECT
  PLURAL=.FALSE.
  IF (OBJECT > 0 .AND. OBJECT <= MAX_OBJECT) PLURAL=BTEST(OBJCON(OBJECT),13)
END function plural

LOGICAL FUNCTION PRINTD(OBJECT)
  USE ALLCOM,only: objcon
  implicit none
  INTEGER,intent(in) :: OBJECT
  PRINTD=BTEST(OBJCON(OBJECT),8)
END function printd

INTEGER FUNCTION PUT(OBJECT,WHER,PVAL)
implicit none
!     SAME AS MOVE, EXCEPT RETURNS A VALUE USED TO SET UP THE NEGATED PROP VALUES FOR THE REPOSITORY OBJECTS.

  INTEGER,intent(in) :: OBJECT,WHER,PVAL

  CALL MOVE(OBJECT, WHER)
  PUT=(-1)-PVAL
END function put

INTEGER FUNCTION RANZ(RANG)
  implicit none
  INTEGER,intent(in) :: RANG
  REAL R

  CALL RANDOM_NUMBER(R)
  RANZ= int(R*RANG)

END function ranz

LOGICAL FUNCTION SMALL(OBJECT)
  USE ALLCOM,only: objcon
implicit none
  INTEGER,intent(in) :: OBJECT
  SMALL=BTEST(OBJCON(OBJECT),5)
END function small

LOGICAL FUNCTION VESSEL(OBJECT)
  USE ALLCOM,only: objcon
implicit none
  INTEGER,intent(in) :: OBJECT
  VESSEL=BTEST(OBJCON(OBJECT),15)
END function vessel

LOGICAL FUNCTION WEARNG(OBJECT)
  USE ALLCOM,only: objcon,wearbt
implicit none
  INTEGER,intent(in) :: OBJECT
  WEARNG=BTEST(OBJCON(OBJECT),WEARBT)
END function wearng

LOGICAL FUNCTION WEARABLE(OBJECT)
  USE ALLCOM,only: objcon
  INTEGER,intent(in) :: OBJECT
  WEARABLE=BTEST(OBJCON(OBJECT),11)
END function wearable